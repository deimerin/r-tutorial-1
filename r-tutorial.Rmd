---
title: " Desarrollo de un Tutorial R"
author: "Rances Rodriguez-, Deimer Castillo - 2101154, Iveth Medina -2183199"
date: '2022-06-11'
output:
  html_notebook: default
---

### 1. Estructuras de control en R
##### 1.1 If
##### 1.2 For
```{r }

```

### 2. Vectores en R
##### 2.1 Creación de vectores
```{r creacion}
c(1, 2, 3, 4)
```
##### 2.2 Indexación de vectores
##### 2.3 Edición de vectores

### 3. Listas y matrices en R
##### 3.1 Operaciones básicas 

### 4. Dataframes
##### 4.1 Visualización y manipulación

### 5. Funciones en R

### 6. Manejo de archivos con R

#### **fs**
Existen diferentes maneras de manejar archivos con R. Para este tutorial mostraremos como manejar archivos con el paquete **fs**, que proporciona una interfaz uniforme y multiplataforma para las operaciones del sistema de archivos. Las funciones del paquete fs se dividen en cuatro categorias principales: 

- path_: para manipular y contruir rutas
- file_: para manipular y construir archivos
- dir_: para manipular y construir directorios
- links_: para manipular y construir enlaces

```{r}
library(fs)
```

A continuacion se presentan algunas acciones basicas para manipular archivos en R. Para una lista completa de las funcionalidades de el paquete **fs** revisar la documentacion [Package ‘fs’](https://cran.r-project.org/web/packages/fs/fs.pdf) 

#### copy --- Copia archivos, directorios o enlaces

##### Descripcion
- file_copy() copia archivos.
- link_copy() crea un nuevo enlace apuntando a la misma ubicacion del enlace anterior.
- dir_copy() copia un directorio recursivamente en una nueva ubicacion.

##### Uso
- file_copy(path, new_path, overwrite = FALSE)
- dir_copy(path, new_path, overwrite = FALSE)
- link_copy(path, new_path, overwrite = FALSE)

##### Argumentos
- path Un vector de caracteres de una o mas rutas.
- new_path Un vector de caracteres de rutas a nuevas ubicaciones.
- overwrite Sobrescribe archivos si existen. Si es FALSE y el archivo existe generara un error.

##### Ejemplos

```{r}

file_create("foo")
file_copy("foo", "bar")
# try(file_copy("foo", "bar"))
file_copy("foo", "bar", overwrite = TRUE)
file_delete(c("foo", "bar"))
dir_create("foo")

# Create a directory and put a few files in it
files <- file_create(c("foo/bar", "foo/baz"))
file_exists(files)

# Copy the directory
dir_copy("foo", "foo2")
file_exists(path("foo2", path_file(files)))

# Create a link to the directory
link_create(path_abs("foo"), "loo")
link_path("loo")
link_copy("loo", "loo2")
link_path("loo2")

# Cleanup
dir_delete(c("foo", "foo2"))
link_delete(c("loo", "loo2"))

```


#### create --- Crea archivos, directorios, o enlaces

##### Descripcion
Las funciones file_create() y dir_create() se aseguran de que la ruta existe; si ya existe se se dejará sin modificar. Esto significa que en comparación con file.create(), file_create() no truncará un archivo existente, y en comparación con dir.create(), dir_create() ignorará silenciosamente los directorios existentes.

##### Uso
- file_create(path, ..., mode = "u=rw,go=r")
- dir_create(path, ..., mode = "u=rwx,go=rx", recurse = TRUE, recursive)
- link_create(path, new_path, symbolic = TRUE)

##### Argumentos
- path Un vector de caracteres de una o mas rutas. Para link_create(), este es el destino.
- ... Argumentos adicionales pasados a path()
- mode Si se crea un archivo/directorio, ¿qué modo debe tener? Los enlaces no tienen modo; heredan el modo del archivo al que enlazan.
- recurse ¿se deben crear directorios intermedios si no existen?
- recursive (Deprecated) Si es TRUE se recurre completamente.
- new_path La ruta donde se debe crear el enlace.
- symbolic Valor booleano que determina si el enlace debe ser simbólico (por defecto) o fuerte.

##### Ejemplos

```{r}
file_create("foo")
is_file("foo")
# dir_create applied to the same path will fail
try(dir_create("foo"))
dir_create("bar")
is_dir("bar")
# file_create applied to the same path will fail
try(file_create("bar"))
# Cleanup
file_delete("foo")
dir_delete("bar")
```

#### delete --- Elimina archivos, directorios y enlaces

##### Descripcion
file_delete() y link_delete() elimina archivos y enlaces. En comparación con file.remove siempre
falla si no pueden eliminar el objeto en lugar de cambiar el valor de retorno o señalar una advertencia. Si alguna de las entradas son directorios, se pasan a dir_delete(), por lo que file_delete() puede utilizarse para borrar cualquier objeto del sistema de archivos.

dir_delete() borrará primero el contenido del directorio y luego eliminará el directorio.

##### Uso
- file_delete(path)
- dir_delete(path)
- link_delete(path)

##### Argumentos
- path Un vector de caracteres de una o mas rutas.

##### Ejemplos
```{r}
# create a directory, with some files and a link to it
dir_create("dir")
files <- file_create(path("dir", letters[1:5]))
link <- link_create(path_abs("dir"), "link")
# All files created
dir_exists("dir")
file_exists(files)
link_exists("link")
file_exists(link_path("link"))
# Delete a file
file_delete(files[1])
file_exists(files[1])
# Delete the directory (which deletes the files as well)
dir_delete("dir")
file_exists(files)
dir_exists("dir")
# The link still exists, but what it points to does not.
link_exists("link")
dir_exists(link_path("link"))
# Delete the link
link_delete("link")
link_exists("link")
```

#### **readr**

El paquete **readr** ofrece funciones para leer data de archivos rectangulares en R. Este paquete hace parte del tidyverse base y sus funciones se ocupan de convertir archivos en data frames.
```{r}
library(tidyverse)
```

Para leer un conjunto de datos rectangulares con readr, se combinan dos partes: una función que analiza las líneas del archivo en campos individuales y una especificación de columna. Una especificación de columna describe cómo debe convertirse cada columna de un vector de caracteres a un tipo de datos específico (por ejemplo, carácter, numérico, fecha y hora, etc.). En ausencia de una especificación de columna, readr deducirá los tipos de columna a partir de los datos.

readr soporta los siguientes formatos de archivo con estas funciones read_*():

- read_csv(): archivos de valores separados por comas (CSV)
- read_tsv(): archivos de valores separados por tabulaciones (TSV)
- read_delim(): archivos delimitados (CSV y TSV son casos especiales importantes)
- read_fwf(): archivos de ancho fijo
- read_table(): archivos separados por espacios en blanco
- read_log(): archivos de registro web

Todas estas funciones tienen una sintaxis similar: una vez se domine una, se podran utilizar las demás con facilidad.

El primer argumento de read_csv() es el más importante: es la ruta del archivo a leer. También se puede suministrar un archivo csv como argumento. Esto es útil para experimentar con readr y para crear ejemplos reproducibles:

```{r}
# Reading data from a CVS file
read_csv('https://vincentarelbundock.github.io/Rdatasets/csv/AER/Guns.csv')
```
```{r}
# Reading data from inline argument
read_csv("a,b,c
          1,2,3
          4,5,6")
```


Cuando se ejecuta read_csv() se imprime una especificación de columna que da el nombre y el tipo de cada columna. A veces hay algunas líneas de metadatos en la parte superior del archivo. Se puede utilizar skip = n para omitir las primeras n líneas; o utilizar comment = "#" para eliminar todas las líneas que empiezan con (por ejemplo) #.

```{r}
read_csv("The first line of metadata
          The second line of metadata
          x,y,z
          1,2,3", skip = 2)
```
```{r}
read_csv("# A comment I want to skip
          x,y,z
          1,2,3", comment = "#")
```


Los datos pueden no tener nombres de columna. Se puede utilizar col_names = FALSE para indicar a read_csv() que no trate la primera fila como encabezados, y en su lugar los etiquete secuencialmente de $X_{1}$ a $X_{n}$:

```{r}
read_csv('https://vincentarelbundock.github.io/Rdatasets/csv/AER/Guns.csv', col_names = FALSE)
```
Otra opción que suele necesitar ajustes es na: especifica el valor (o los valores) que se utilizan para representar los valores que faltan en el archivo:

```{r}
read_csv("a,b,c\n1,2,.", na = ".")
```




### 7. Ejemplos de visualización de datos

### **ggplot**

```{r}

```



